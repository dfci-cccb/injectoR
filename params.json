{"name":"injectoR","tagline":"Dependency Injection Framework for R","body":"Injector is meant to ease development making it clear what parts of your script depend on what\r\nother functionality without cluttering your interface\r\n\r\n```R\r\ndefine (three = function () 3,\r\n        power = function (power)\r\n                  function (x, n) if (n < 1) 1 else x * power (x, n - 1));\r\ndefine (cube = function (power, three) function (x) power (x, three));\r\n\r\ninject (function (cube) cube (4));\r\n```\r\n\r\nDefine collections to accumulate bindings and have the collection injected as a (optionally\r\nnamed) list\r\n\r\n```R\r\nadd.food <- multibind ('food');\r\n\r\nadd.food (function () 'pizza');\r\nmultibind ('food') (function () 'ice cream');\r\nadd.food (pretzel = function () 'pretzel');\r\n\r\ninject (function (food) food);\r\n\r\n# Useful as plugin system, you can chain your dependencies recursively\r\ndefine (dispatch = function (listeners)\r\n                     function (event, context)\r\n                       listeners[[ event ]] (context));\r\nmultibind ('listeners') (yell = function () function (context)\r\n                                              print (context),\r\n                         follow = function (dispatch)\r\n                                    function (context) {\r\n                                      print ('follow');\r\n                                      dispatch ('yell', context);\r\n                                    });\r\n\r\ninject (function (dispatch) dispatch ('follow', 'hello world'));\r\n```\r\n\r\nShimming a library will define each of its globally exported variables. Shimming does not call\r\nlibrary() so it will not export variables in the global namespace. Shimming and injecting is\r\nbetter than calling library() because it defines clear boundaries of dependency, and while an\r\noriginal result may depend on a library a derived will not have this explicit dependency \r\nallowing you to switch the original implementations at will\r\n\r\n```R\r\nshim ('agrmt');\r\n\r\ninject (function (modes) {\r\n  # do stuff with modes()\r\n});\r\n\r\nshim (s4 = 'stats4', callback = function (s4.AIC) {\r\n  # do stuff with stats4's AIC()\r\n});\r\n\r\n# Useful idiom for shimming libraries in an anonymous binder without\r\n# polluting the root binder (or whatever binder you're using)\r\nshim (b = 'base', s = 'stats',\r\n      callback = function (b.loadNamespace, b.getNamespaceExports, s.setNames) {\r\n  # Define something useful into your root binder\r\n  define (exports = function () function (...)\r\n    lapply (s.setNames (nm = c (...)), function (package)\r\n      b.getNamespaceExports (b.loadNamespace (package))));\r\n}, binder = binder ());\r\n```\r\n\r\nYou may optionally inject or provide a default value\r\n\r\n```R\r\ndefine (greeting = function (name = \"stranger\") print (paste (\"Greetings,\", name)));\r\n\r\ninject (function (greeting) {});\r\n\r\ndefine (name = function () 'Bob');\r\n\r\ninject (function (greeting) {});\r\n```\r\n\r\nYou may scope your bindings\r\n\r\n```R\r\ndefine (counter = function () {\r\n  count <- 0;\r\n  function () count <<- count + 1;\r\n}, singleton);\r\n\r\ninject (function (counter) {\r\n  print (counter ());\r\n});\r\n\r\ninject (function (counter) {\r\n  print (counter ());\r\n});\r\n```\r\n\r\nExtensible!\r\n\r\n```R\r\n# Provide your own binding environment\r\nbinder <- binder ();\r\n\r\ndefine (foo = function (bar = 'bar') {\r\n  # Factory for foo\r\n}, scope = function (provider) {\r\n  # The scope is called at definition time and is injected with the\r\n  # provider function; provider function takes no arguments and is\r\n  # responsible for provisioning the dependency, the scope function\r\n  # is responsible for appropriately calling it and caching result\r\n  # when necessary. Provider is the wrapped factory injection call\r\n}, binder = binder);\r\n```","google":"UA-61122183-1","note":"Don't delete this file! It's used internally to help with page regeneration."}